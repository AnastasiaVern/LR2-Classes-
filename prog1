#include "stdafx.h"
#include <iostream>
#include <string.h> // no need
#include <tchar.h> // зачем?
#include <string>
#include <stdlib.h> // why use c-library header?


using namespace::std; // using namespace std;
class Sotrudnik
{   
	       friend class FriendSotrudnik; // форматирование
	 string surname; // форматирование
	int  oklad;
	double more;
	friend void print(const Sotrudnik &x);
	               
public:
	explicit Sotrudnik(int oklad) { oklad = 0; }; // зачем тогда принимается параметр?

	Sotrudnik() 
	{
		surname = "default";
		oklad = 0;
		more = 0;
	};
	Sotrudnik(string sur, int s, double b)  // объекты лучше получать по ссылке, чтобы они не копировались (string)
	{ 
		               surname=sur; // форматирование
	                     oklad = s;
	                      more = b; // форматирование
	}
	
	// форматирование
		 double zarplata() const 
		 {
			 return oklad + (more / 100.);
		 };
		 void print() const
		 { 
			  cout << "  \n Surname of the epmloyee :\n " << surname; // std::endl вместо \n
			  cout<< "  \nHis salary: \n " << oklad;
			  cout << " \n His bonus:\n " << more;
			  cout<< " \n Total salary: \n" << oklad + (more / 100.); // а если расчет зарплаты изменится, править в двух местах?

		 };

	                                
		
		 ~Sotrudnik() {}; // Советую сделать здесь cout << "object destroyed" << endl;
};

class FriendSotrudnik 
{ public: 
	void printFriendSotrudnik(const Sotrudnik &y) 
	{
		cout << "Sotrudnik\n\n";
		cout << y.surname;
		cout << y.oklad;
		cout << y.more;

	};
};
double zar(int x, double y) // unused?
{
	return double(x) + (y/100);
};

void printSotrudnik(const Sotrudnik* s) { // unused?
	s->print();
}

void print(const Sotrudnik &x) 
{ 
	cout << x.surname;
	cout << x.oklad;
	cout << x.more;
}

int main()
{
	// В с++ объявление может стоять где угодно внутри блока, поэтому принято переносить объявление ближе к месту использования.
	Sotrudnik x;
	FriendSotrudnik yfriend;
	int n;
	string sur;
	double b,sum=0;
	int s;
	cout << "vvedite kol-vo sotrudnikov" << endl;
	cin >> n;
	Sotrudnik **p;
	p = new Sotrudnik*[n];


	double* sal = new double[n]; // зачем нужен этот массив, если вы храните объекты Сотрудник?
	for (int i = 0; i < n; i++) // https://books.google.ru/books?id=mmjVIC6WolgC&pg=PT147&lpg=PT147&dq=sutter+prefix+increment#v=onepage&q=sutter%20prefix%20increment&f=false
	{    
		cout << "\nEmployee number  " << (i + 1) << "\n" << "Surname please:\n ";
		cin.clear();
		cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
		getline(cin,sur);
		

		cout << sur;
		
		cout << "\nHis/her salary: \n";
		cin >> s;
		cout << "\nBonus salary: \n";
		cin >> b;
		cout << "\nTotal salary: \n";
		          p[i] = new Sotrudnik(sur, s, b); // форматирование
		                    sal[i] = p[i]->zarplata();
		                                   cout << sal[i];
 	};
	for (int i = 0; i<n; i++) p[i]->print();
	for (int j = 0; j < n; j++) sum += sal[j]; // p[j]->zarplata()
	cout << "\nTotal Summ = \n " << sum;
	cout << "\n\n";

	print(x);
	cout << "\n\n";
	yfriend.printFriendSotrudnik(x);

	delete p; // p is an array
	delete[]sal;
	
	// Предлагаю удивиться, что cout << "object destroyed" << endl; выполнится только один раз для объекта x,
	// хотя создано было явно больше сотрудников. 

    return 0;
}

